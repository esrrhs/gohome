package cryptonight

import (
	"fmt"
	"testing"

	"github.com/esrrhs/gohome/common"
)

func TestFinalHash(t *testing.T) {
	expect := [][]byte{
		// [6 91 137 91 228 85 47 16 49 62 34 119 235 161 152 8 73 147 191 147 47 183 51 61 188 32 111 224 251 182 1 76]
		{6, 91, 137, 91, 228, 85, 47, 16, 49, 62, 34, 119, 235, 161, 152, 8,
			73, 147, 191, 147, 47, 183, 51, 61, 188, 32, 111, 224, 251, 182, 1, 76},
		// [102 28 18 86 88 90 192 176 244 220 10 30 231 40 116 168 179 62 236 185 21 36 197 73 244 229 81 180 98 242 133 11]
		{102, 28, 18, 86, 88, 90, 192, 176, 244, 220, 10, 30, 231, 40, 116, 168,
			179, 62, 236, 185, 21, 36, 197, 73, 244, 229, 81, 180, 98, 242, 133, 11},
		// [160 119 219 123 238 42 158 103 95 106 94 98 250 112 228 75 174 134 175 152 36 254 13 223 98 52 71 179 163 44 133 159]
		{160, 119, 219, 123, 238, 42, 158, 103, 95, 106, 94, 98, 250, 112, 228, 75,
			174, 134, 175, 152, 36, 254, 13, 223, 98, 52, 71, 179, 163, 44, 133, 159},
		// [3 49 0 236 127 178 56 249 40 182 83 222 91 135 64 30 224 99 246 151 39 27 160 71 137 241 193 13 213 238 203 142]
		{3, 49, 0, 236, 127, 178, 56, 249, 40, 182, 83, 222, 91, 135, 64, 30,
			224, 99, 246, 151, 39, 27, 160, 71, 137, 241, 193, 13, 213, 238, 203, 142},
	}
	for i0 := 0; i0 < 4; i0++ {
		cc := NewCryptoNight()
		for i := range cc.finalState {
			cc.finalState[i] = uint64(i * 1000000000)
		}
		cc.finalState[0] = uint64(i0) // 0, 1, 2, 3
		sum := cc.finalHash()
		if len(sum) != 32 {
			t.Fatalf("expected 32 bytes, got %d bytes\n", len(sum))
		}
		fmt.Println("FinalHash Test", i0, ":", sum)
		for i, v := range expect[i0] {
			if sum[i] != v {
				t.Errorf("FinalHash Test %d: expected byte %d to be %d, got %d", i0, i, v, sum[i])
			}
		}
	}
}

func TestFinalHash_BE(t *testing.T) {
	common.DebugSetBigEndian(true)
	defer common.DebugResetBigEndian()

	expect := [][]byte{
		// [6 91 137 91 228 85 47 16 49 62 34 119 235 161 152 8 73 147 191 147 47 183 51 61 188 32 111 224 251 182 1 76]
		{6, 91, 137, 91, 228, 85, 47, 16, 49, 62, 34, 119, 235, 161, 152, 8,
			73, 147, 191, 147, 47, 183, 51, 61, 188, 32, 111, 224, 251, 182, 1, 76},
		// [102 28 18 86 88 90 192 176 244 220 10 30 231 40 116 168 179 62 236 185 21 36 197 73 244 229 81 180 98 242 133 11]
		{102, 28, 18, 86, 88, 90, 192, 176, 244, 220, 10, 30, 231, 40, 116, 168,
			179, 62, 236, 185, 21, 36, 197, 73, 244, 229, 81, 180, 98, 242, 133, 11},
		// [160 119 219 123 238 42 158 103 95 106 94 98 250 112 228 75 174 134 175 152 36 254 13 223 98 52 71 179 163 44 133 159]
		{160, 119, 219, 123, 238, 42, 158, 103, 95, 106, 94, 98, 250, 112, 228, 75,
			174, 134, 175, 152, 36, 254, 13, 223, 98, 52, 71, 179, 163, 44, 133, 159},
		// [3 49 0 236 127 178 56 249 40 182 83 222 91 135 64 30 224 99 246 151 39 27 160 71 137 241 193 13 213 238 203 142]
		{3, 49, 0, 236, 127, 178, 56, 249, 40, 182, 83, 222, 91, 135, 64, 30,
			224, 99, 246, 151, 39, 27, 160, 71, 137, 241, 193, 13, 213, 238, 203, 142},
	}
	for i0 := 0; i0 < 4; i0++ {
		cc := NewCryptoNight()
		for i := range cc.finalState {
			cc.finalState[i] = uint64(i * 1000000000)
		}
		cc.finalState[0] = uint64(i0) // 0, 1, 2, 3
		sum := cc.finalHash()
		if len(sum) != 32 {
			t.Fatalf("expected 32 bytes, got %d bytes\n", len(sum))
		}
		fmt.Println("FinalHash Test", i0, ":", sum)
		for i, v := range expect[i0] {
			if sum[i] != v {
				t.Errorf("FinalHash Test %d: expected byte %d to be %d, got %d", i0, i, v, sum[i])
			}
		}
	}
}
